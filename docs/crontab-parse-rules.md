# Crontab 解析规则说明

## 核心概念

- **任务行**：已生效的 cron 任务 或 已注释的 cron 任务（`#` + cron表达式）
- **注释行**：普通注释（`#` 开头但不符合 cron 表达式格式）
- **空行**：不含任何字符的行，空行只会打断任务后紧跟的注释的连续性

---

## 新组识别规则

以下两种情况标志着**开始新的任务组**：

### 情况一：任务 + 空行 + 注释行

空行前为任务行，且空行后紧跟注释行时，开始新组。

```
任务A
         ← 空行
# 注释   ← 新组开始
任务B
```

### 情况二：任务 + 严格连续多行注释（≥2行）

出现任务之后紧跟**严格连续**（无空行分隔）的2行及以上注释时，开始新组。

```
任务A
# 注释1  ← 严格连续注释开始，新组开始
# 注释2
任务B
```

**注意**：只有任务后紧跟的注释遇到空行才会打断连续性，以下情况**不触发情况二但触发情况一**：
```
任务A
# 注释1  ← 任务后紧跟，comment_after_task=true
         ← 空行，打断连续性
# 注释2  ← 清空buffer，buffer=[注释2]
任务B    ← 与任务A同组，注释2为任务名
```

---

## 组名识别规则

在确定新组开始后，按以下规则识别组名：

| 注释行数 | 组名选取 |
|----------|----------|
| 1行 | 该注释 = 组名 |
| 2行及以上 | 倒数第二行 = 组名 |

---

## 任务名识别规则

**规则**：任务行上方第一个非空行的注释行，若未被选为组名 → 作为该任务的任务名

---

## 完整示例

### 示例1：任务 + 空行 + 单行注释
```
任务A
         ← 空行
# 组名   ← 新组开始，组名
任务B    ← 无任务名
```

### 示例2：任务 + 空行 + 双行注释
```
任务A
         ← 空行
# 组名    ← 新组开始，倒数第二行 = 组名
# 任务名  ← 任务名
任务B
```

### 示例3：任务 + 无空行 + 双行注释
```
任务A
# 组名    ← 连续注释开始新组，倒数第二行 = 组名
# 任务名  ← 任务名
任务B
```

### 示例4：任务 + 无空行 + 单行注释（不开始新组）
```
任务A
# 任务名  ← 只有1行注释，不开始新组，仅作为任务名
任务B     ← 与任务A同组
```

### 示例5：三行严格连续注释
```
任务A
# 描述    ← 严格连续注释开始，被忽略
# 组名    ← 倒数第二行 = 组名
# 任务名  ← 任务名
任务B
```

### 示例6：空行后的注释不受打断规则影响
```
任务A
         ← 空行，触发情况一（任务+空行）
# 注释1   ← 空行后的注释，comment_after_task=false
         ← 空行，不打断（因为注释不是紧跟任务的）
# 注释2   ← buffer=[注释1, 注释2]
任务B     ← 新组（情况一），组名=注释1，任务名=注释2
```

**说明**：空行打断规则只适用于"任务后紧跟的注释"，空行后的注释不受影响。

### 示例6.1：任务+注释+空行+注释（打断连续性）
```
任务A
# 注释1   ← 任务后紧跟，comment_after_task=true
         ← 空行，打断（因为 comment_after_task=true）
# 注释2   ← 清空buffer，buffer=[注释2]
任务B     ← 与任务A同组，注释2=任务名
```

**说明**：任务后紧跟的注释遇到空行会打断连续性，使情况二不生效。

### 示例6.5：任务+注释+空行（注释当作空行）
```
任务A
# 注释    ← 上一行是任务，下一行是空行 → 当作空行处理，不加入buffer
         ← 空行
# 组名    ← buffer=1行
任务B     ← 新组，组名=组名
```

**说明**：任务行后紧跟的单行注释，如果下一行是空行，则该注释被忽略（当作空行）。

### 示例7：文件开头
```
# 组名    ← 视同空行后，单行注释 = 组名
任务A
```

### 示例8：文件开头 + 多行注释
```
# 组名    ← 倒数第二行 = 组名
# 任务名  ← 任务名
任务A
```

### 示例9：注释行下方没有任何任务行
```
# 描述    ← 被忽略
          ← 空行
# 描述    ← 被忽略
# 描述    ← 被忽略
← crontab结束
```

---

## 规则流程图

```
初始化：
  - comment_buffer = []          # 注释缓冲区
  - new_group_context = true     # 文件开头视同空行后
  - comment_after_task = false   # 注释是否紧跟任务行
  - last_non_empty_is_task = false  # 上一个非空行是否是任务行
  - current_group = 新组

遍历每一行：
│
├─ 空行？
│   ├─ 如果上一个非空行是任务行 → new_group_context = true
│   └─ 如果 comment_buffer 非空 且 comment_after_task = true
│      → 标记 comment_interrupted = true（只打断任务后紧跟的注释）
│
├─ 注释行？
│   ├─ 特殊情况：上一行是任务行 且 下一行是空行 → 当作空行处理
│   │   └─ new_group_context = true，不加入 buffer
│   ├─ 如果 comment_interrupted = true → 清空 comment_buffer（打断连续性）
│   ├─ 如果 buffer 为空 → comment_after_task = (上一行是否为任务行)
│   ├─ 加入 comment_buffer
│   └─ 如果 comment_buffer.length >= 2 且 comment_after_task = true
│      → new_group_context = true（情况二：任务后严格连续多行注释）
│
└─ 任务行？
    │
    ├─ 【判断是否开始新组】
    │   条件：new_group_context == true 且 comment_buffer 非空
    │   │
    │   ├─ 是 → 结束当前组（如有任务），开始新组
    │   │       ├─ 1行注释 → 该注释 = 组名，任务无任务名
    │   │       └─ 多行注释 → 倒数第二行 = 组名，最后一行 = 任务名
    │   │
    │   └─ 否 → 保持当前组
    │           └─ 如果 comment_buffer 有1行 → 该注释 = 任务名
    │
    ├─ 任务加入当前组
    │
    └─ 重置状态
        ├─ 清空 comment_buffer
        └─ new_group_context = false

遍历结束：
  └─ 如果 current_group 有任务 → 保存该组
```

### 补充说明

| 场景 | new_group_context | comment_buffer | 结果 |
|------|-------------------|----------------|------|
| 空行 + 单行注释 + 任务 | true | 1行 | 新组，注释=组名 |
| 空行 + 多行注释 + 任务 | true | ≥2行 | 新组，倒数第二行=组名 |
| 任务 + 严格连续多行注释 + 任务 | true（≥2行且紧跟任务） | ≥2行 | 新组，倒数第二行=组名 |
| 任务 + 单行注释 + 任务 | false | 1行 | 同组，注释=任务名 |
| 空行 + 任务（无注释） | true | 0行 | 同组（条件不满足） |
| 任务 + 注释 + 空行 + 注释 + 任务 | false（打断） | 1行 | 同组，最后注释=任务名 |
| 任务 + 空行 + 注释 + 空行 + 注释 + 任务 | true | 2行（空行后不打断） | 新组（情况一），组名+任务名 |

---
